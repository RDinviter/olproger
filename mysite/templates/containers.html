<html>
<head>
 <link rel="stylesheet" href="static/css/about_olimp.css">
</head>

<body>
  <form class="main_text">
    <div class="txt">
      <h1 class="title"><b>Контейнеры</b></h1>
      <h2 style='text-align: center;' class="title"><b>stack (стек)</b></h2>
      <p class="comments"><b>Класс std::stack&lt;T&gt;</b> представляет <b>stack (стек)</b> - структуру данных, которая работает по принципу LIFO
(last-in first-out или "последний вошел — первым вышел") — первым всегда
извлекается последний добавленный элемент. Стек можно сравнить со стопкой
предметов, например, стопкой тарелок - тарелки добавляются сверху, каждая
последующая тарелка кладется поверх предыдущей. А если надо взять тарелку,
то сначала берется та, которая в самом верху (которую положили самой последней).</p>
      <p class="tab">Для работы со стеком надо подключать заголовочный файл &ltstack&gt;.</p>
<h2>Функции стека</h2>
<div class='define'>
.push(...) - положить элемент в конец стека, работает за O(1)<br>
.pop() - удалить элемент с верхушки стека, работает за O(1)<br>
.top() - возращает элемент с верхушки, работает за O(1)<br>
.size() - возвращает количество элементов в стеке, работает за O(1)<br>
.empty() - возвращает true, если стек пустой, false, если в нем есть элементы<br>
</div>
<pre class="code">
#include &ltiostream>
#include &ltstack>

int main() {
    // пустой стек интов
    stack&ltint> numbers;
    // добавляем элементы
    numbers.push(1);
    numbers.push(2);
    numbers.push(3);

    // Извлекаем элементы
    while (!numbers.empty()) {
        // показываем верхний элемент
        cout << numbers.top() << " ";

        // удаляем верхний элемент
        numbers.pop();
    }
    return 0;
}
</pre>
<h2 style='text-align: center;' class="title">queue (очередь)</h2>
<p class="comments"><b>Класс std::queue&ltT></b> представляет очередь - контейнер, который работает по
принципу FIFO (first-in first-out или "первый вошел — первым вышел") — первым
всегда извлекается первый добавленный элемент. То есть это контейнер,
аналогичный стандартной очереди, которая часто встречается в нашей повседневной
жизни.</p>

<h2>Функции очереди</h2>
<div class='define'>
.push(...) - положить элемент в конец очереди, работает за O(1)<br>
.pop() - удалить элемент из начала очереди, работает за O(1)<br>
.front() - возращает первый элемент, работает за O(1)<br>
.size() - возвращает количество элементов в очереди, работает за O(1)<br>
.empty() - возвращает true, если очередь пустая, false, если в ней есть элементы<br>
</div>
<pre class="code">
#include &ltiostream>
#include &ltqueue>

int main() {
    //создаем пустую очередь
    queue&ltint> numbers;

    // добавляем элементы
    numbers.push(1);
    numbers.push(2);
    numbers.push(3);

    // извлекаем элементы
    while (!numbers.empty()) {
        // показываем первый элемент
        cout << numbers.front() << " ";
        // удаляем первый элемент
        numbers.pop();
    }
    return 0;
}
</pre>
<h2 style='text-align: center;' class='title'>deque (дек)</h2>
<p class="comments">Двусторонней очередью (деком) называется динамический массив, допускающий эффективные операции с обеих сторон. Как и вектор, двусторонняя очередь предоставляет функции push_back и pop_back, но вдобавок к ним
функции push_front и pop_front. Используется она следующим образом:</p>
<pre class='code'>
deque&ltint> d;
d.push_back(5); // [5]
d.push_back(2); // [5,2]
d.push_front(3); // [3,5,2]
d.pop_back(); // [3,5]
d.pop_front(); // [5]
</pre>
<h2>Функции дека</h2>
<div class='define'>
<b>d[index]</b>: получение элемента по индексу<br><br>
<b>.at(index)</b>: возращает элемент по индексу<br><br>

<b>.front()</b>: возвращает первый элемент<br><br>
<b>.back()</b>: возвращает последний элемент<br><br>
<b>.push_back(val)</b>: добавляет значение val в конец очереди<br><br>

<b>.push_front(val)</b>: добавляет значение val в начало очереди<br><br>

<b>.emplace_back(val)</b>: добавляет значение val в конец очереди<br><br>

<b>.emplace_front(val)</b>: добавляет значение val в начало очереди<br><br>

<b>.emplace(pos, val)</b>: вставляет элемент val на позицию, на которую указывает итератор pos. Возвращает итератор на добавленный элемент<br><br>

<b>.insert(pos, val)</b>: вставляет элемент val на позицию, на которую указывает итератор pos, аналогично функции emplace. Возвращает итератор на добавленный элемент<br><br>

<b>insert(pos, n, val)</b>: вставляет n элементов val начиная с позиции, на которую указывает итератор pos. Возвращает итератор на первый добавленный элемент. Если n = 0, то возвращается итератор pos.<br><br>

<b>insert(pos, begin, end)</b>: вставляет начиная с позиции, на которую указывает итератор pos, элементы из другого контейнера из диапазона между итераторами begin и end. Возвращает итератор на первый добавленный элемент. Если между итераторами begin и end нет элементов, то возвращается итератор pos.<br><br>

<b>.insert(pos, values)</b>: вставляет список значений values начиная с позиции, на которую указывает итератор pos. Возвращает итератор на первый добавленный элемент. Если values не содержит элементов, то возвращается итератор pos.<br><br>
</div>
Более подробно про функции дека:
<a class='problems' href="https://metanit.com/cpp/tutorial/7.8.php">тык</a>
<pre class="code">
#include &ltiostream>
#include &ltdeque>

int main() {
    deque&ltint> numbers = {2, 3, 4};

    // добавляем элемент в начало
    numbers.push_front(1);

    // дбавляем элемент в конец
    numbers.push_back(5);

    // доступ к элементам
    cout << "First element: "
     << numbers.front() << '\n';

    cout << "Last element: "
     << numbers.back() << '\n';

    // удаление первого элемента
    numbers.pop_front();

    // итерация по deque
    for(int num : numbers) {
        cout << num << " ";
    }
    return 0;
}
</pre>
<h2 style='text-align: center;'>vector</h2>
<p class="comments">Вектор представляет контейнер (динамический массив), который содержит коллекцию объектов одного типа и позволяет эффективно
добавлять элементы в конце и удалять последние элементы.</p>
У вектора те же функции, что и у дека за исключением того, что в векторе нет такого бытрого добавления в начало и удаления из начала. Но зато некоторые другие функции реализованы эффективнее.
<pre class='code'>
#include &ltiostream>
#include &ltvector>

int main() {
    vector&ltint> numbers = {1, 2, 3, 4, 5};
    numbers.push_back(6); // добавляем элемент в конец

    // доступ к элементам
    cout &lt&lt&lt "Third element: "
     &lt&lt numbers[2] &lt&lt'\n';

    // итерация по vector
    for(int num : numbers) {
        cout &lt&lt num &lt&lt " ";
    }
    return 0;
}
</pre>
<h2>Задачи</h2>
<form>
<a class="problems" href="https://codeforces.com/problemset/problem/1214/C?mobile=true&locale=ru">Задача на ПСП</a>
</form>

    </div>
  </form>
</body>
</html>
