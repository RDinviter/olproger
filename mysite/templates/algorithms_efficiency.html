<html>
<head>
 <link rel="stylesheet" href="static/css/about_olimp.css">
</head>

<body>
  <form class="main_text">
    <div class="txt">
      <h2>Временная сложность</h2>
        <p class="comments"><i>Временная сложность алгоритма</i> – это оценка того, сколько времени будет
работать алгоритм при заданных входных данных. Зная временную сложность, мы зачастую можем сказать, достаточно ли алгоритм быстрый для
решения задачи, даже не реализуя его.</p>
<p class="tab">Для описания временной сложности применяется нотация O(…), где
многоточием представлена некоторая функция. Обычно буквой n обозначается размер входных данных. Например, если на вход подается массив
чисел, то n – это размер массива, а если строка, то n – длина строки</p>
  <h2>Правила вычисления</h2>
  <p class="tab">Если код включает только линейную последовательность команд, как, например, показанный ниже, то его временная сложность равна O(1).</p>
  <pre class="code">
a++;
b++;
c = a+b;
</pre>
<p class="tab">Временная сложность цикла оценивает число выполненных итераций.
Например, временная сложность следующего кода равна O(n), поскольку код внутри цикла выполняется n раз. При этом предполагается, что многоточием «…» обозначен код с временной сложностью O(1).</p>
<pre class="code">
for (int i = 1; i <= n; i++) {
   ...
}
</pre>
<p class="tab">Временная сложность следующего кода равна O(n<sup>2</sup>):</p>
<pre class="code">
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        ...
    }
}
</pre>
<p class="comments">Вообще, если имеется k вложенных циклов и в каждом цикле перебирается n значений, то временная сложность равна O(n<sup>k</sup>).</p>

<p class="tab">Временная сложность не сообщает, сколько точно раз выполняется код
внутри цикла, она показывает лишь порядок величины, игнорируя постоянные множители. В примерах ниже код внутри цикла выполняется 3n,
n + 5 и ⌈n/2⌉ раз, но временная сложность в каждом случае равна O(n).</p>
<pre class="code">
for (int i = 1; i <= 3*n; i++) {
    ...
}
</pre>
<pre class="code">
for (int i = 1; i <= n+5; i++) {
    ...
}
</pre>
<pre class="code">
for (int i = 1; i <= n; i += 2) {
    ...
}
</pre>
<p class="tab">С другой стороны, временная сложность следующего кода равна O(n<sup>2</sup>),
поскольку код внутри цикла выполняется 1 + 2 + … + n = ½(n2 + n) раз.</p>
<pre class="code">
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        ...
    }
}
</pre>
<p class='tab'>Если алгоритм состоит из нескольких последовательных частей, то общая
временная сложность равна максимуму из временных сложностей отдельных частей,
 т. е. самая медленная часть является узким местом. Так, следующий код состоит
  из трех частей с временной сложностью O(n), O(n<sup>2</sup>)
и O(n). Поэтому общая временная сложность равна O(n<sup>2</sup>).
<pre class="code">
for (int i = 1; i <= n; i++) {
    ...
}
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= n; j++) {
        ...
    }
}
for (int i = 1; i <= n; i++) {
    ...
}
</pre>
<p class='tab'>Иногда временная сложность зависит от нескольких факторов, поэтому
формула включает несколько переменных. Например, временная сложность следующего
кода равна O(nm):</p>
<pre class="code">
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        ...
    }
}
</pre>
<p class='tab'>Временная сложность рекурсивной функции зависит от того, сколько
раз она вызывается, и от временной сложности одного вызова. Общая
временная сложность равна произведению того и другого. Рассмотрим, к
примеру, следующую функцию:</p>
<pre class="code">
void f(int n) {
    if (n == 1) return;
    f(n-1);
}
</pre>
<p class='tab'>Вызов f(n) приводит к n вызовам функций, и временная сложность
каждого вызова равна O(1), поэтому общая временная сложность равна O(n).
В качестве еще одного примера рассмотрим следующую функцию:</p>
<pre class="code">
void g(int n) {
    if (n == 1) return;
    g(n-1);
    g(n-1);
}
</pre>
<p class='tab'>Что происходит, когда эта функция вызывается с параметром n?
Сначала она будет дважды вызвана с параметром n−1, затем четыре раза
с параметром n − 2, потом восемь раз с параметром n − 3 и т. д. Вообще, будет
2<sup>k</sup> вызовов с параметром n – k, где k = 0, 1, …, n − 1. Таким образом, общая
временная сложность равна<br>
1 + 2 + 4 + … + 2n−1 = 2n − 1 = O(2<sup>n</sup>).</p>
<h2>Часто встречающиеся оценки временной сложности</h2>


<p class="tab">Ниже перечислены часто встречающиеся оценки временной сложности
алгоритмов.</p>

<p class="comments">O(1) Время работы алгоритма с <i>постоянным</i> временем не зависит от
размера входных данных. Типичным примером может служить явная формула,
 по которой вычисляется ответ.</p>
<p class="comments">O(log n) В <i>логарифмическом</i> алгоритме размер входных данных на
каждом шаге обычно уменьшается вдвое. Время работы зависит от
размера входных данных логарифмически, поскольку log<sub>2</sub>n – это
сколько раз нужно разделить n на 2, чтобы получить 1. Отметим, что
основание логарифма во временной сложности не указывается.</p>
<p class="comments">O(√n) Алгоритм с временной сложностью O(√n) медленнее, чем O(log n),
но быстрее, чем O(n). Специальное свойство квадратного корня заключается в том, что √n = n/√n, т. е. n элементов можно разбить на
O(√n) порций по O(√n) элементов.</p>
<p class="comments">O(n) <i>Линейный</i> алгоритм перебирает входные данные постоянное число раз. Зачастую это наилучшая возможная временная сложность,
потому что обычно, чтобы получить ответ, необходимо обратиться
к каждому элементу хотя бы один раз.</p>
<p class="comments">O(n log n) Такая временная сложность часто означает, что
алгоритм сортирует входные данные, поскольку временная сложность эффективных
алгоритмов сортировки равна O(n log n). Есть и другая возможность – в
алгоритме используется структура данных, для которой каждая операция
занимает время O(log n).</p>
<p class="comments">O(n<sup>2</sup>) Квадратичный алгоритм нердко содержит два вложенных цикла.
Перебрать все пары входных элементов можно за время O(n2
).</p>
<p class="comments">O(n<sup>3</sup>) Кубический алгоритм часто содержит три вложенных цикла. Все
тройки входных элементов можно перебрать за время O(n3
).</p>
<p class="comments">O(2<sup>n</sup>) Такая временная сложность нередко указывает на то, что
алгоритм перебирает все подмножества множества входных данных. Например,
подмножествами множества {1, 2, 3} являются ∅, {1}, {2}, {3},
{1, 2}, {1, 3}, {2, 3} и {1, 2, 3}.</p>
<p class="comments">O(n!) Такая временная сложность часто означает, что алгоритм перебирает все перестановки входных элементов. Например, перестановками множества {1, 2, 3} являются (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1),
(3, 1, 2) и (3, 2, 1).</p>

 <h2>Оценка временной сложности по размеру входных данных</h2>
<pre class="define">Размер входных данных и ожидаемая временная сложность</p>
      n ≤ 10        O(n!)<br>
      n ≤ 20        O(2<sup>n</sup>)<br>
      n ≤ 500       O(n<sup>3</sup>)<br>
      n ≤ 5000      O(n<sup>2</sup>)<br>
      n ≤ 10<sup>6</sup>       O(n log n) или O(n)<br>
      n велико      O(1) или O(log n)<br></pre>
<b><p class="tab">Примеры</p></b>

<p class="tab">Пусть дан массив n чисел; наша первая задача заключается в том, чтобы
вычислить максимальную сумму подмассивов, т. е. наибольшую возможную
сумму последовательных элементов. Задача приобретает интерес, когда в
массиве встречаются элементы с отрицательными значениями.</p>
Вот пример массива:<br>
 {-1, 2, 4, -3, 5, 2, -5, 2}<br>
 {-1, <b>2</b>, <b>4</b>, <b>-3</b>, <b>5</b>, <b>2</b>, -5, 2}<br>
Подмассивом с максимальной суммой
является [2, 4, –3, 5, 2]. Его сумма равна 10.
<p class="tab"><b>Решение со сложностью O(n<sup>3</sup>)</b>. Задачу можно решить в лоб: перебрать
все возможные подмассивы, вычислить сумму элементов в каждом подмассиве и запомнить максимальную сумму. Этот алгоритм реализован в
следующем коде:<br>
<pre class="code">
int best = 0;
for (int a = 0; a &lt; n; a++) {
    for (int b = a; b &lt; n; b++) {
    int sum = 0;
        for (int k = a; k &lt;= b; k++) {
            sum += array[k];
        }
        best = max(best,sum);
    }
}
cout &lt;&lt; best &lt;&lt; "\n";
</pre>

<p class="tab">В переменных a и b хранятся первый и последний индекс подмассива, а
в переменную sum записывается сумма его элементов. В переменной best
хранится максимальная сумма, найденная в процессе просмотра. Временная сложность этого алгоритма равна O(n3
), поскольку налицо три вложенных цикла, в которых перебираются входные данные.</p>

<p class="tab"><b>Решение со сложностью O(n<sup>2</sup>).</b> Алгоритм легко сделать более эффективным, исключив один цикл. Для этого будем вычислять сумму одновременно со сдвигом правого конца подмассива. В результате получается
такой код:<br>
<pre class="code">
int best = 0;
for (int a = 0; a &lt; n; a++) {
    int sum = 0;
    for (int b = a; b &lt; n; b++) {
       sum += array[b];
       best = max(best,sum);
    }
}
cout &lt;&lt; best &lt;&lt; "\n";
</pre>
<p class="tab">После подобного изменения временная сложность становится равна
O(n<sup>2</sup>).</p>
<p class="tab"><b>Решение со сложностью O(n).</b> Оказывается, что задачу можно решить
и за время O(n), т.  е. достаточно и одного цикла. Идея в том, чтобы для
каждой позиции массива вычислять максимальную сумму подмассива,
заканчивающегося в этой позиции. Тогда для получения окончательного
ответа достаточно будет взять максимум из этих сумм.</p>
Рассмотрим подзадачу нахождения подмассива с максимальной суммой, заканчивающегося в позиции k. Есть две возможности:
<p class="tab">1. Подмассив состоит из единственного элемента в позиции k.</p>
<p class="tab">2. Подмассив состоит из подмассива, заканчивающегося в позиции
k − 1, за которым следует элемент в позиции k.</p>
<p class="tab">Во втором случае, поскольку мы ищем подмассив с максимальной суммой, сумма подмассива, заканчивающегося в позиции k – 1, также должна
быть максимальной. Таким образом, задачу можно решить эффективно,
если вычислять сумму максимального подмассива для каждой позиции
последнего элемента слева направо.</p>
<p class="tab">Алгоритм реализуется следующей программой:</p>
<pre class="code">
int best = 0, sum = 0;
for (int k = 0; k &lt; n; k++) {
    sum = max(array[k],sum+array[k]);
    best = max(best,sum);
}
cout &lt;&lt; best &lt;&lt; "\n";
</pre>
<p class="tab">В этом алгоритме только один цикл, в котором перебираются входные
данные, поэтому его временная сложность равна O(n). Лучшей сложности

добиться нельзя, поскольку любой алгоритм решения этой задачи должен
хотя бы один раз проанализировать каждый элемент.</p>
    </div>
  </form>
</body>
</html>
