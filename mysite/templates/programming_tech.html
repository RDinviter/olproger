<html>
<head>
 <link rel="stylesheet" href="static/css/about_olimp.css">
</head>

<body>
  <form class="main_text">
    <div class="txt">
      <h2>Языковые средства</h2>
<p class='tab'>Типичная олимпиадная программа на C++ устроена
 по такому образцу:</p>
<pre class="code">
#include "bits/stdc++.h"
using namespace std;
int main() {
  // здесь находится решение
}
</pre>
<p class='comments'>Строка <i>#include</i> в начале программы - специфика компилятора g++,
она служит для включения всей стандартной библиотеки. Таким образом, не
 нужно по отдельности включать такие библиотеки, как <i>iostream, vector</i> и
  <i>algorithm;</i> все они автоматически становятся доступны.
В строке <i>using</i> объявляется, что все классы и функции из
 стандартной библиотеки можно использовать без указания пространства имен.
  Не будь using, нужно было бы писать, к примеру, std::cout, а так
  достаточно просто
cout.</p>


<h2>Ввод и вывод</h2>
<p class='tab'>В большинстве олимпиадных задач для ввода и вывода
 используются стандартные потоки. В С++ стандартный поток ввода называется
  <b>cin</b>, a стандартный поток вывода <b>cout</b>. Можно также использовать С-функции,
   например scanf и printf.

Входными данными для программы обычно являются числа и строки, разделенные пробелами и знаками новой строки. Из потока cin они читаются следующим образом:</p>
<pre class="code">
int a, b; string x;
cin >> a >> b >> x;
</pre>
<p class='tab'>Такой код работает в предположении, что элементы потока разделены хотя
 бы одним пробелом или знаком новой строки. Например, приведенный выше
  код может прочитать как входные данные:</p><br>
123 456 monkey<br><br>
так и входные данные:<br><br>
123 456<br>
monkey<br><br>
<p class='tab'>Поток cout используется для вывода:</p>

<pre class="code">int a = 123, b = 456;
string x = "monkey";
cout &lt;&lt; a &lt;&lt; " " &lt;&lt; b &lt;&lt; " " &lt;&lt; x &lt;&lt; "\n";
</pre>
&nbsp;&nbsp;&nbsp;&nbsp;Ввод и вывод часто оказываются узкими
 местами программы. Чтобы повысить эффективность ввода-вывода,
 можно поместить в начало программы такие строки:<br>
<pre class="code">
ios::sync_with_stdio(0);
cin.tie(0);
</pre>
<p class='tab'>Отметим, что знак новой строки "\n" работает быстрее, чем endl, потому что endl всегда сопровождается
сбросом буфера.</p>


<p class='tab'>Иногда программа должна прочитать целую входную
 строку, быть может, содержащую пробелы. Это можно сделать с помощью функции
<b>getline</b>:</p>
<pre class="code">
string s;
getline(cin, s);
</pre>
<p class='tab'>Если объем данных заранее неизвестен, то полезен такой цикл:</p>
<pre class="code">
while (cin >> x) {
// код
}
</pre>
<p class='tab'>Этот цикл читает из стандартного ввода элементы один
 за другим, пока
входные данные не закончатся.</p>
<p class='tab'>В некоторых олимпиадных системах для ввода и вывода используются файлы.
 В таком случае есть простое решение: писать код так, будто работаешь со
  стандартными потоками, но в начало программы добавить такие строки:</p>
  <pre class="code">
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);
</pre>
<p class='tab'>После этого программа будет читать данные из файла «input.txt»,
 a записывать в файл «output.txt».</p><br>

<h2>Работа с числами</h2>
<p class='tab'><i>Целые числа.</i> Из целых типов в олимпиадном программировании
чаще всего используется int - 32-разрядный тип, принимающий значения из
 диапазона -2<sup>31</sup>...2<sup>31</sup> - 1
 (приблизительно -2<sup>10</sup>...2<sup>10</sup>). Если типа
  int недостаточно, то можно взять 64-разрядный тип <b>long long</b>. Диапазон его
   значений -2<sup>63</sup>...2<sup>63</sup> - 1
   (приблизительно 9*10<sup>18</sup>...9*10<sup>18</sup>).
Ниже определена переменная типа long long:</p>
<pre class="code">
long long x = 123456789123456789LL;
</pre>
 <p class='tab'>Cуффикс LL означает, что число имеет тип long long.<br>
  Типичная ошибка при использовании типа long long возникает,
   когда где-то в программе встречается еще и тип int. Например,
    в следующем коде есть тонкая ошибка:</p>
<pre class="code">
int a = 123456789;
long long b = а*а;
cout &lt;&lt; b << "\n"; // -1757895751
</pre>
 <p class='tab'>Хотя переменная b имеет тип <i>long long</i>, оба сомножителя в выражении a*a
имеют тип <i>int</i>, поэтому тип результата тоже int. Из-за этого значение b
оказывается неверным. Проблему можно решить, изменив тип а на long long
или изменив само выражение на (long long)a*a. </p>
<p class='tab'>Обычно олимпиадные задачи
формулируются так, что типа long long достаточно. Но все же полезно знать,
что компилятор g++ поддерживает также 128-разрядный тип <b>__int128_t</b>
с диапазоном значений -2<sup>127</sup>...2<sup>127</sup> - 1
(приблизительно -10<sup>38</sup>...10<sup>38</sup>). Однако этот тип
доступен не во всех олимпиадных системах.</p>
 <h2>Арифметика по модулю.</h2>
 <p class='tab'> Иногда ответом является очень большое
  число, но достаточно <i>вывести результат «по модулю m»</i>,
  т. е. остаток от деления на m (например, «7 по модулю 10<sup>9</sup>»).
  Идея в том, что даже когда истинный ответ очень велик, типов int и long long
  все равно достаточно.</p>
  <p class='tab'>Остаток x от деления на m обозначается x mod m.
  Например, 17 mod 5 =2, поскольку 17 = 3*5 + 2. Важные свойства остатков
 выражаются следующими формулами:</p>
 <pre class="code">
(a+b) mod m = (а mod m + b mod m) mod m;
(a-b) mod m = (а mod m - b mod m) mod m;
(b-а) mod m= (а mod m - b mod m) mod m.
</pre>
<p class='tab'>Это значит, что можно брать остаток после каждой
операции, поэтому числа никогда не станут слишком большими.
Например, следующий код вычисляет n! (n факториал) по модулю m:</p>
 <pre class="code">
long Long x = 1;
for (int i = 1; i <=n; i++) {
 x = (x*i)%m;
}
cout &lt;&lt; x << "\n";
</pre>
<p class='tab'>Обычно мы хотим. чтобы остаток находился в диапазоне
0...m - 1. Но в С++ и в других языках остаток от деления отрицательного числа
равен нулю или отрицателен. Чтобы не возникали отрицательные остатки, можно
поступить  следующим образом: сначала вычислить остаток, а если он отрицателен,
прибавить m:</p>
<pre class="code">
x = x%m;
if (x &lt; 0) x += m;
</pre>
<p class='tab'>Но это стоит делать, только если в программе
встречается операция вычитания, так что остаток может стать отрицательным.
</p>
<h2>Числа с плавающей точкой.</h2>
<p class='tab'> В большинстве олимпиадных задач целых
чисел достаточно, но иногда возникает потребность в числах с плавающей
точкой. В C++ наиболее полезен 64-разрядный тип double, а в компиляторе
g++ имеется расширение – 80-разрядный тип long double. Чаще всего типа
double достаточно, но long double дает более высокую точность.<br>
&nbsp;&nbsp;&nbsp;&nbsp;Требуемая точность ответа обычно указывается в формулировке задачи.
Проще всего для вывода ответа использовать функцию printf и указать
количество десятичных цифр в форматной строке. Например, следующий
код печатает значение x с 9 цифрами после запятой:</p>
<pre class="code">
printf("%.9f\n", x);
</pre>
Есть и другой способ:
<pre class="code">
#include &lt;iomanip&gt;
cout &lt;&lt;fixed&lt;&lt;setprecision(9);
</pre>
<p class='tab'>С использованием чисел с плавающей точкой связана одна
сложность: некоторые числа невозможно точно представить в таком формате,
поэтому неизбежны ошибки округления. Например, в следующем коде получается
значение x, немного меньшее 1, тогда как правильное значение равно в точности 1.</p>
<pre class="code">
double x = 0.3*3+0.1;
printf("%.20f\n", x); // 0.99999999999999988898
</pre>
<p class='tab'>Числа с плавающей точкой рискованно сравнивать с помощью оператора ==, потому что иногда равные значения оказываются различны из-за
ошибок округления. Более правильно считать, что два числа равны, если
разность между ними меньше ε, где ε мало. Например, в следующем коде
ε = 10<sup>−9</sup>:</p>
<pre class="code">
if (abs(a-b) &lt; 1e-9) {
    // a и b равны
}
</pre>
<p class='tab'>Отметим, что хотя числа с плавающей точкой, вообще говоря, не точны,
не слишком большие целые числа представляются точно. Так, тип double
позволяет точно представить все целые числа, по абсолютной величине не
большие 2<sup>53</sup>.</p>

<h2>Сокращение кода</h2><br>
<p class='tab'><i>Имена типов.</i> Ключевое слово typedef позволяет сопоставить типу данных короткое имя. Например, имя long long слишком длинное, поэтому
можно определить для него короткий псевдоним ll:</p>
<pre class="code">
typedef long long ll;
</pre>
<p class='tab'>После этого код</p>
<pre class="code">
long long a = 123456789;
long long b = 987654321;
cout &lt;&lt; a*b << "\n";
</pre>
можно немного сократить:
<pre class="code">
ll a = 123456789;
ll b = 987654321;
cout &lt;&lt; a*b << "\n";
</pre>
<p class='tab'>Ключевое слово typedef применимо и к более сложным типам.
Например, ниже мы сопоставляем вектору целых чисел имя vi, а паре двух целых
чисел – тип pi.</p>
<pre class="code">
typedef vector&lt;int&gt; vi;
typedef pair&lt;int,int&gt; pi;
</pre>
<h2>Макросы.</h2>
<p class='tab'> Еще один способ сократить код – макросы. Макрос говорит,
что определенные строки кода следует подменить до компиляции. В C++
макросы определяются с помощью ключевого слова #define.
Например, мы можем определить следующие макросы:</p>
<pre class="code">
#define F first
#define S second
#define PB push_back
#define MP make_pair
</pre>
<p class='tab'>После чего код</p>
<pre class="code">
v.push_back(make_pair(y1,x1));
v.push_back(make_pair(y2,x2));
int d = v[i].first+v[i].second;
</pre>
<p class='tab'>можно сократить до:</p>
<pre class="code">
v.PB(MP(y1,x1));
v.PB(MP(y2,x2));
int d = v[i].F+v[i].S;
</pre>
<p class='tab'>У макроса могут быть параметры, что позволяет сокращать циклы и
другие структуры. Например, можно определить такой макрос:</p>
<pre class="code">
#define REP(i,a,b) for (int i = a; i <= b; i++)
</pre>
<p class='tab'>После этого код</p>
<pre class="code">
for (int i = 1; i <= n; i++) {
 search(i);
}
</pre>
<p class='tab'>можно сократить следующим образом:</p>
<pre class="code">
REP(i,1,n) {
 search(i);
}
</pre>
    </div>
  </form>
</body>
</html>
