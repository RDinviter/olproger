<html>
<head>
 <link rel="stylesheet" href="static/css/about_olimp.css">
</head>

<body>
  <form class="main_text">
    <div class="txt">
      <h1 class="title"><b>Два указателя</b></h1>
        <div class='comments'><b>Метод двух указателей</b> — это техника, используемая для решения различных задач на массивах и строках, при которой используются два указателя (индекса), которые перемещаются по данным по определённым правилам.</div>
        <p class="tab">Рассмотрим задачу:<br>
        a, b - отсортированные массивы длины n и m соответственно. Нужно найти количество чисел, содержащихся и в a, и в b (длину пересечения).
        </p>
        <p class="tab">Банальное решение(полный перебор всех вариантов) будет работать на O(nm), но не будет оптимальным.
          Так как массивы отсортированны, мы можем завести 2 переменные i и j, которые будут индексами наших массивов. В случае, если элементы a[i] и b[j] равны, значит мы нашли равные элементы, можем инкрементировать переменную-счетчик, а также значение i и j.<br>
          В случае a[i] < b[j] мы просто увеличим переменную i (a[i + 1] >= a[i] так как массивы отсортированны по условию)
          В ином случае, инкрементируем j.
        </p>
        <div class='comments'>Инкременти́ровать - увеличивать (увеличить) на единицу.</div>

<pre class='code'>
int i = 0;
int j = 0;
int ans = 0;

while(i < n and j < m) {
   if (a[i] == b[j]) {
       ans++;
       i++;
       j++;
   } else {
       if (a[i] < b[j]) {
           i++;
       } else {
           j++;
       }
   }
}
</pre>
<p class='tab'>Рассмотрим еще одну задачу:<br>
a, b - отсортированные массивы. Требуется объединить их в один отсортированный массив. </p>
<p class='tab'>Банальным решением будет конкатенировать два списка в один и вызвать функцию sort(). Алгоритмическая сложность будет O(n log n) (время работы встроенной сортировки). Но решение можно сделать за O(n):</p>

<div class="comments">Конкатенация — это процесс объединения двух последовательностей в одну.</div>

<p class='tab'>Как и в прошлой задаче создаем 2 указателя i и j, которые изначально будут указывать на начало массивов.
Далее если a[i] < b[j], то в итоговый массив добавляем a[i] и и двигаем указатель i. (можно записать res.push_back(a[i++]). Тут мы используем постинкремент,  который сначала вернет текущее значение i, а потом увеличит его.  Так делать можно, но это затрудняет чтение кода)
В ином случаве добавляем b[j] и увелисиваем j.
Также нетрудно доказать, что до конца своего массива дойдет всего один из указателей, а второй до конца не дойдет и в массиве останутся элементы. Для исправления этого используем дополнительные циклы.
</p>
<div class="comments">Постинкремент - сначала возвращает текущее значение переменной, затем увеличивает её на единицу.</div>
<div class="comments">Преинкремент - сначала увеличивает значение переменной на единицу, затем возвращает её.</div>

<pre class='code'>
int i = 0;
int j = 0;
vector&ltint>  res;

while (i &lt n and j &lt m) {
   if (a[i] <= b[j]) {
       res.push_back(a[i]);
       i++;
   } else {
       res.push_back(b[j++]);
   }
   while (i &lt n) {
       res.push_back(a[i++]);
   }
   while (j &lt m) {
       res.push_back(b[j]);
       j++;
   }
}
</pre>
<p class='tab'>Эназер задача:<br>
  На прямой находятся N точек; требуется подсчитать количество пар точек,
  расстояние между которыми ≥ D.<br> Решение: сортируем точки по координате
(если они не отсортированы во входных данных). Идем одним указателем i от 1 до N,
второй указатель j меняем так, чтобы среди точек, лежащих "правее" i
(т.е. с бОльшими номерами) он указывал на самую "левую" точку такую,
что расстояние от точки i до точки j было ≥ D. На каждом шагу добавляем к
ответу N−j+1 — это общее количество точек, лежащих правее i на расстоянии
как минимум D от нее. Поскольку при увеличении i значение j тоже может только
увеличиваться, то метод двух указателей сработает.
</p>
<pre class='code'>
int i = 0;
int j = 0;
int ans = 0;

for (int i = 0; i < n - 1; i++) {
    while (j + 1 < n and x[j + 1] - x[i] <= D) {
      j++;
    }
    ans += n - j + 1;
}
</pre>
  </div>
  </form>
</body>
</html>
