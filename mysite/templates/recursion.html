<html>
<head>
 <link rel="stylesheet" href="static/css/about_olimp.css">
</head>

<body>
  <form class="main_text">
    <div class="txt">
      <h1 class="title"><b>Рекурсия</b></h1>
      <p class='comments'><b>Рекурсия</b> — это процесс вызова функции самой собой в качестве подпрограммы для решения сложной задачи. Он предполагает деление программы на подзадачи и их повторный вызов вместо итеративного метода, который занимает много времени на решение той же задачи.</p>
      <p class='tab'><i>Рекурсивным</i> называется объект, определение которого включает само себя.
То есть этот объект имеет самозамкнутое определение.</p>
      <p class='tab'> Каждая рекурсивная
функция состоит из двух частей: базового случая и рекурсивного случая.
В рекурсивном случае функция вызывает сама себя. В базовом случае
функция себя не вызывает, чтобы предотвратить зацикливание. Иначе, программа будет выполняться бесконечно.</p>
      <p class='tab'>Рассмотрим задачу. Нам нужно вывести все числа от 1 до n. Пользоваться контейнерами и циклами запарещено.</p>
      <p class='tab'>Попробуем сформулировать задачу рекурсивно. Когда нам нужно будет завершить вывод? Тогда, когда n будет равняться 1. В ином случае вызываем функцию вывода с параметром n-1.</p>
<pre class='code'>
void f(int n) {
    if (n == 1) { // базовый случай
        cout << n << ' ';
        return;
    }
    cout << n << ' ';
    f(n - 1); // рекурсивный вызов
}
</pre>
<p class='tab'>Через рекурсию также удобно считать <i>факториал</i> числа.</p>
<p class='comments'>Факториал числа n — это произведение натуральных чисел от 1 до n. Обозначается как n! (произносится «эн факториал»).
Пример: 5! = 1 × 2 × 3 × 4 × 5 = 120.</p>
<p class='tab'>Попробуем найти факториал числа n. Это можно сделать и итеративно, но легче будет применить рекурсию. Нам, как и в прошлой задаче нужно будет остановиться тогда, когда n будет равно единице исходя из определения факториала. В ином случае вызываем функцию с параметром n - 1.</p>
<pre class='code'>
int f(int n) {
    if (n == 1) {
        return 1;
    }
    return f(n - 1) * n;
}
</pre>
<p  class='tab'>Советую взять листок с ручкой и попробовать рассмотреть вызов функий. Это позволяет легче понять, что делает ваш код.</p>
<p  class='tab'>Еще с помощью рекурсии удобно искать <i>числа Фибоначчи</i>.</p>
<p class='comments'>Числа Фибоначчи - элементы числовой последовательности, в  которой первые два числа равны 0 и 1, а каждое последующее число равно сумме двух предыдущих чисел. Иногда член F<sub>0</sub> равный нулю, опускается — тогда последовательность Фибоначчи начинается с F<sub>1</sub> = F<sub>2</sub> = 1.</p>

<pre class='define'>
F<sub>0</sub> = 0
F<sub>1</sub> = 1
F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub>
</pre>
<p  class='tab'>Если внимательно посмотреть на определение чисел Фибоначчи, то станосится ясно, что и базовый, и рекурсивный случай нам уже даны. Осталось только описать их кодом:</p>
<pre class='code'>
int fib(int n) {
    if (n <= 2) return 1;
    return fib(n - 1) + fib(n - 2);
}
</pre>
<p  class='tab'>Сложность тут получается велика, O(c<sup>n</sup>). Но ее можно упростить до O(n) с помощью <i>меморизации</i>.</p>
<p class='comments'>Мемоизация в программировании — это метод оптимизации, который ускоряет работу программ, сохраняя и впоследствии повторно используя результаты функций, вызванных с одинаковыми аргументами.<br>Перед вызовом функции проверяется, вызывалась ли она ранее. Если не вызывалась, то функция вызывается, и результат её выполнения сохраняется. Если вызывалась, то используется сохранённый результат. </p>
<p class'tab'>Для запоминания будем использовать мапу. Значением first будет значение n, на второй позиции будет fib(n). Сохранение позволит нам каждый раз заново не вычислять значение функции, если мы его уже вычислил до этого. Мы будет брать его из нашей мапы (ее нужно будет создать как глобальный объект, либо создать в функции main() и передавать в fib() по ссылке).</p>
<pre class='code'>
map&ltint, int> mem;

int fib(int n) {
    if (n <= 2) return 1;
    if (mem.contains(n)) return mem[n];

    mem[n] = fib(n - 1) + fib(n - 2);
    return mem[n];
}
</pre>
<p class='comments'><b>Важно!<br></b>
Функция mem.contains(n) работает только от стандарта C++20. Вместо нее можно использовать mem.find(n) != mem.end(). Данная реализация будет доступна на всех стандартаз С++.
</p>
<p  class='tab'>Рассмотрим еще одну задачу:</p>
<p  class='tab'>Дана последовательность, оканчивающаяся на 0. Нужно вывести её в обратном порядке. Пользоваться контейнерами запрещено.</p>
<p  class='tab'>Данная задача похожа на первую, рассмотренную в данной теме. Базовый случай - введеное число равно нулю. В этом случае выводим число. В ином случае, вызываем функцию еще раз.</p>
<pre class='code'>
void solve() {
    int x;
    cin >> x;
    if (x != 0) {
        solve();
    }
    cout << x << ' ';
}
</pre>

<p class = 'tab'>Еще одна задача - генерация всех двоичных строк длины n. Базовый случай - строка полностью заполнена. В этом случае выводим строку и return'им. В ином случае нам надо добавить либо 0, либо 1 в конец и вызвать функцию генерации еще раз. Это можно сделать с помощью цикла. Также не стоит забывать, что если мы что то добавили, то после использования нам нужно это удалить. Всего будет сгенерированно 2<sup>n</sup> строк.</p>
<pre class = 'code'>
void gen(vector&ltint> &cur, int n) {
    if (cur.size() >= n) {
        for (auto i : cur) {
            cout << i ;
        }
        cout << '\n';
        return;
    }
    for (int number  = 0; number <= 1; number++) {
        cur.push_back(number);
        gen(cur, n);
        cur.pop_back();
    }
}
</pre>
      </div>
  </form>
</body>
</html>
