<html>
<head>
 <link rel="stylesheet" href="static/css/about_olimp.css">
</head>

<body>
  <form class="main_text">
    <div class="txt">
      <h1 class="title"><b>Бинарный поиск</b></h1>
      <h2 class="title"><b>Чойта такое?</b></h2>
      <p class='tab'><b>Бинарный поиск</b> — тип поискового алгоритма, который последовательно делит пополам заранее отсортированный массив данных, чтобы обнаружить нужный элемент.</p>

      <p class='tab'>Я загадал число X от 1 до 100. Вы можете спрашивать, больше ли мое число чем число T, я отвечаю “да” или “нет”. За сколько вопросов в худшем случае вы сможете найти число X? Как нужно действовать?<br></p>
      <p class='tab'><b>Решение</b> и состоит в идее бинарного (двоичного) поиска - нужно первым вопросом спросить “число X больше, чем 50?”. После этого, если ответ “нет”, надо спросить “число X больше, чем 25”? И так далее, нужно уменьшать отрезок возможных значений в два раза каждый раз.</p>
      <p class='tab'>Почему нужно делить обязательно пополам? Почему бы не спросить “число X больше, чем 80?” первым же вопросом? Но если вдруг ответ “нет”, то мы останемся с 80 вариантами вместо 100. То есть деление отрезка ровно пополам гарантирует, что в худшем случае мы останемся не более чем с половиной вариантов.</p>
      <p class='tab'>Чтобы понять, как быстро это работает, введём новую математическую функцию. Логарифмом по основанию a от b будем называть число c, такое что a<sup>c</sup>=b
      Обозначается как log<sub>a</sub>b=c. Чаще всего мы будем работать с двоичным логарифмом, то есть в какую степень c нужно возвести двойку, чтобы получить b. Поэтому договоримся, что запись log n означает двочный логарифм n.</p>
      <p class='tab'>Теперь вернёмся к нашей задаче. Можно понять, что такой алгоритм работает как раз за O(log n) вопросов (если число 100 на заменить абстрактную переменную n). есложно убедиться, что именно логарифм раз нужно поделить число на два, чтобы получилось 1.
      Обычный поиск (итерация по всем элементам списка) будет работать за O(n)</p>
      <p class='tab'><b>И это очень быстро!</b></p>
      <p class='tab'>Предположим, что секретному агнту <b>Ингвару</b> очень нужно найти один невероятно важный элемент в отсортированном массиве элементов.
        Допустим, проверка одного элемента занимает 1 миллисекунду (мс). При
        простом поиске Ингвару придется проверить 100 элементов, поэтому поиск
        займет 100 мс. С другой стороны, при бинарном поиске достаточно проверить всего 7 элементов (log<sub>2</sub>100 равен приблизительно 7), а поиск займет
        7 мс. Но реальный список может содержать более миллиарда элементов.
      </p>
      <p class="tab"> Время выполнения для простого
поиска с 1 миллиардом элементов составит 1 миллиард миллисекунд, а это
11 дней! Проблема в том, что время выполнения для бинарного и простого
поиска растет с разной скоростью. </p>
      <p class='aligncenter'>
        <a href="https://iimg.su/i/8S5aD">
          <img alt="bin_search" src="https://s.iimg.su/s/18/dQroCsVb56GH68Y6uGlSJW3dkqBVCkWVnUEmtkDj.jpg" class='photo'>
        </a>
      </p>
    <p class='tab'>Другими словами, с увеличением количества элементов бинарный поиск
занимает <i>чуть</i> больше времени. А простой поиск займет <i>гораздо</i> больше
времени.</p>
    <p class='tab'>Рассмотрим реализацию данного алгоритма сразу на примере задачи:<br>
      Дан отсортированный массив a длины n. Проверить, есть ли такое i, что a[i] = x. Если есть, то вывести Yes, в ином случае - No.
    </p>
    <p class='tab'>Также хочу добавить, что в конец массива надо положить очень большое число, которое не войдет в нашу последовательность (например, если в задаче написано, что х не превышает 10<sup>9</sup>, то в конец массива можно положить 10<sup>9</sup> + 7) Это мы делаем на тот случай, если х больше всех чисел в массиве. Тогда, если мы не сделаем эту операцию, бинарный поиск выйдет за пределы массива и мы получим UB.</p>
<div class='comments'>UB или Undefined behavior (неопределенное поведение) - это поведение, которое может возникать в результате использования ошибочных программных конструкций или некорректных данных, на которые стандарт не налагает никаких требований. (например, выход за границы массива)</div>
<pre class='code'>
int l = 0;
int r = n - 1;
const int inf = 1e9 + 7;

a.push_back(inf);

while ((l + 1) &lt r) {
    int m = (l + r) / 2;
    if (a[m] > x) {
      r = m;
    } else {
      l = m;
    }
}

if (a[l] == x) {
    cout &lt&lt "Yes";
} else {
    cout &lt&lt "No";
}
</pre>


<p class='tab'>Пока указатель l меньше указателя r, берем средний элемент и сравниваем его с искомым. Если а[i] > x, то все, что правее a[i] нас не интересует, поэтому сдвигаем указатель r. В ином случае двигаем указатель l.</p>
<div class='comments'>Также хочу отметить, что в C++ есть встроенная реализация  бинарного поиска. Для работы нам нужно написать<br><br>

#include &ltalgorithm><br><br>

В фунцию передаем итераторы на начало и конец списка, а также искомый элемент. Если элемент есть в списке, функция веренет true, в ином случае - false.<br><br>
binary_search(a.begin(), a.end(), x);<br></div>

<p class='tab'>Рассмотрим еще одну задачу:</p>
<p class='tab'>Даны отсортированный массив a длины n и число k. Нужно найти такое минимальное k, при котором a[k] >= x</p>
<p class='tab'>Решение почти аналогично решению предыдущей задачи, но есть несколько различий (мы ищем не обязательно само число х, а число, которое будет больше или равно). Соответственно, вывод ответа у нас тоже будет различаться.
<pre class='code'>
a.push_back(inf);

int l = -1, r = n;

while (l + 1 &lt r) {
    m = (l + r) / 2;
    if (a[m] >= x) {
        r = m;
    } else {
        l = m;
    }
}
if (r == n) {
    cout << "NO";
} else {
    cout &lt&lt a[r];
}
</pre>

<div class='comments'>В C++ есть встроенная реализация данного алгоритма. Она тоже находится в "algorithm", называется lower_bound, она возвращает число, не меньшее того, которое в нее передали. Имеет такой синтаксис:<br><br>
lower_bound(a.begin(), a.end(), x) // вернет само число<br>
lower_bound(a.begin(), a.end(), x) - a.begin() // вернет индекс этого числа <br>
</div>
<div class='comments'>Также в C++ есть функция upper_bound, которое возвращает первое значение, бОльшее х. Синтаксис аналогичен lower_bound.</div>
<h2>Бинарный поиск по ответу</h2>
<p class='tab'><b>БП</b> по ответу  заключается в том, чтобы сформулировать задачу как «найти максимальное х такое, что такое-то легко вычислимое свойство от х выполняется» и найти этот х бинпоиском</p>
<p class='tab'>Рассмотрим данный алгоритм на примере задач</p>
<b>«Принтеры»</b>
<p class='tab'>Сегодня утром жюри решило добавить в вариант олимпиады еще одну, Очень Легкую Задачу. Ответственный секретарь Оргкомитета напечатал ее условие в одном экземпляре, и теперь ему нужно до начала олимпиады успеть сделать еще n  копий. В его распоряжении имеются два ксерокса, один из которых копирует лист за x секунд, а другой  — за y. Разрешается использовать как один ксерокс, так и оба одновременно. Можно копировать не только с оригинала, но и с копии. Помогите жюри выяснить, какое минимальное время для этого потребуется.</p>
<p class='tab'>Логично, что для ускорения работы нам хочется использовать 2 принтера сразу. Превое, что хочется отметить - изначально у нас всего одна копия, соответственно мы можем использовать всего лишь один принтер. Для полной производительности нам нужно сделать еще одну копию за min(x, y). Кажется, существует прямое решение с формулой. Но вместо того, чтобы о нем думать, можно просто свести задачу к обратной. Давайте подумаем, как по числу минут
t (ответу) понять, сколько листов напечатается за это время? Очень легко:</p>
<p class="aligncenter">n = (t/x) + (t/y)</p>
<p class='tab'>Границей слева для бинарного поиска может быть -1 минут (мы должны учитывать, что ответ может быть и 0 минут) и max(x * n) для границы справа.</p>
<pre class='code'>
int binary_search_by_ans(int n, int x, int y) {
    int l = -1, r = n * max(x, y);
    n -= 1;
    int m;
    while (l + 1 &lt r) {
        m = (l + r) / 2;
        if (m / x + m / y >= n) {
            r = m;
        } else {
            l = m;
        }
      }
    return r + min(x, y);
}
</pre>
<p class='tab'>Перейдем к следующей задаче</p>
<b>Квадратный корень и квадратный квадрат</b>
<p class='tab'>Найдите такое число x, что x<sup>2</sup> + √x = C, с точностью не менее 6 знаков после точки.
<p class='tab'>Первое, что хочется заметить: х - неотрицательное число. (х<sup>2</sup> >= 0; при √x тоже х не может быть отрицательным числом). Тогда 0 и будет нашей левой грницей для поиска. Правой будет с, так как искомый х точно будет меньше с.</p> <p class='tab'> Также хочется отметить, что поиск будет вестись по дробным числам. Соответственно условие l + 1 &lt r не будет нас удовлетворять. Можно сделать l - r >= 10<sup>-7</sup>, но может случиться так, что мы перескочим это условие и уйдем в бесконечный цикл. Нам  намного легче сделать определенное (установленное заранее) число итераций. Нам точно хватит log<sup>2</sup>((r-l) * 10<sup>7</sup>). Это около 100 шагов.</p>
<pre class='code'>
double bin_s(double c) {
    double l = 0, r = c;
    for (int i = 0; i &lt 100; i++) {
        double m = (l + r) / 2;
        if (m * m + sqrt(m) &lt c) {
            l = m;
        } else {
            r = m;
        }
    }
    return r;
}
</pre>
    </div>
  </form>
</body>
</html>
